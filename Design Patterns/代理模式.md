## 概念

代理模式，顾名思义就是帮助别人做事，为其他对象提供一种代理以控制这个对象的访问。

作用：

1. 远程代理（一个对象将不同空间的对象进行局部代理）
2. 虚拟代理（根据需要创建开销很大的对象，如渲染网页暂时用占位符代替真图）
3. 安全代理（控制真实对象的访问权限）
4. 智能指引（调用对象代理处理另外一些事情，如垃圾回收机制）

注意事项：

1. 不能滥用代理，有时候滥用代理仅仅只是给代码增加复杂度。

## 用例

以下，讲的是`保护代理`的一个实例：User类表示的是提供给用户的所有操作，ProxyForum类表示的是对User类中所有操作的代理。ProxyForum会根据传入的User的code值判断当前用户是否有该操作的权限，如果有则调用，没有则输出没有权限。

```javascript
function User (name, code) {
  this.name = name
  this.code = code
}

User.prototype = {
  getName: function () { return this.name },
  getCode: function () { return this.code },
  post: function (msg) { console.log('post a message:' + msg) },
  remove: function () { console.log('remove a message') },
  comment: function () { console.log('comment a message') }
}

function ProxyForum (user) {
  this.user = user
}

ProxyForum.prototype = {
  getUser: function () { return this.user },
  post: function (msg) {
    if (this.user.getCode() === '001' || this.user.getCode() === '003') {
      this.user.post(msg)
    } else {
      console.log('No Access To Post A Message')
    }
  },
  remove: function () {
    if(this.user.getCode() === '002' || this.user.getCode() === '003') {
      this.user.remove()
    } else {
      console.log('No Access To Remove A Message')
    }
  },
  comment: function () {
    if (this.user.getCode() === '003') {
      this.user.comment()
    } else {
      console.log('No Access To Comment A Message')
    }
  }
}

var proxyUser = new ProxyForum( new User('Barney', '001') )
proxyUser.getUser()
proxyUser.post('Hello Wrold!')
proxyUser.remove()
proxyUser.comment()
```

这样做的好处是，User只需要负责完成用户的操作而不用再去判断用户是否有权限这么做。如果我们想要改变用户权限的时候，不需要去修改User类，而是直接去修改ProxyForum类。如果当我们不需要权限控制的时候，可以直接将接口指向User类，删除ProxyForum类就可以了，而不需要去修改User。

除了权限代理以外，还有缓存代理，可以将复杂的、频繁使用的操作的结果缓存起来。下面的例子中，Mult和Plus分别返回的是将传入的数字的乘积和总和。ProxyFactory会根据传入函数来处理，将操作的结果缓存在cache这个对象中。如果再次操作，发现传入的值是一样的，直接从cache中获取，避免再次计算。

```javascript
var Mult = function () {
  var a = 1
  for (var i = 0; i < arguments.length; i++) {
    a = a * arguments[i]
  }
  return a
}

var Plus = function () {
  var a = 0
  for (var i = 0; i < arguments.length; i++) {
    a += arguments[i]
  }
  return a
}
var ProxyFactory = function (fn) {
  var cache = {}
  return function () {
    var args = Array.prototype.join.call(arguments, ',')
    if (args in cache) {
      return cache[args]
    }
    return cache[args] = fn.apply(this, arguments)
  }
}

var m = ProxyFactory(Mult)
var p = ProxyFactory(Plus)

console.time('test1')
console.log(m(1,2,3,4))
console.timeEnd('test1')

console.log(m(1,2,3,4))
console.time('test2')
console.timeEnd('test2')

console.time('test3')
console.log(p(6,7,8,9))
console.timeEnd('test3')

console.time('test4')
console.log(p(6,7,8,9))
console.timeEnd('test4')
```

得到的结果是：

24
test1: 13.110ms
24
test2: 0.036ms
30
test3: 1.361ms
30
test4: 0.693ms

参考资料：https://blog.csdn.net/qq_35585701/article/details/79938315
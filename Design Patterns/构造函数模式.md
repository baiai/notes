## 概念

1. 用于创建特定类型的对象
2. 第一次声明的时候给对象赋值
3. 自己声明构造函数，赋予属性和方法

注意事项：

1. 声明函数的时候处理业务逻辑
2. 区分和单例模式的区别，配合单例实现初始化
3. 构造函数大写字母开头（建议）
4. 注意new的成本（继承）

## 创建

在JS中创建一个对象很简单，比如字面量表示法，但是如果我们需要根据指定生成特定的对象呢？那么这个时候就需要用到构造函数模式了。比如：

```javascript
function Person (name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayHi = function () {
        console.log(
            `Hello, I am ${this.name}, I am ${this.age} years old, I am a ${this.job}`
        );
    }
}
var Barney = new Person('Barney', 30, 'Business Man');
Barney.sayHi(); // Hello, I am Barney, I am 30 years old, I am a Business Man
```

这样就可以通过传入的参数定义每个对象的姓名、年龄、工作和打招呼的方式。但是这也有很多缺点：

​	一是如果我们没有用new去构建对象的话，函数无法正常使用。

​	二是每次构造函数都要去实例一个相同的sayHi方法。

要解决第一个问题可以使用如下的方式，代码如下：

```javascript
function Person (name, age, job) {
  if(!(this instanceof Person)) {
    return new Person(name, age, job);
  }
  this.name = name ? name : 'no name';
  this.age = age ? age : 0;
  this.job = job ? job : 'no job';
  this.sayHi = function () {
      console.log(
          `Hello, I am ${this.name}, I am ${this.age} years old, I am a ${this.job}`
      );
  }
}
var Barney = Person('Barney', 30, 'Business Man');
Barney.sayHi(); // Hello, I am Barney, I am 30 years old, I am a Business Man
```

从输出可以看出，即使没有使用new，但是Person返回的认识一个new过的对象，保证了构造函数的对象一定是通过new得到的。

至于第二个问题，有两种解决方法，一个是将共有的属性和方法放在函数体外，比如：

```javascript
function Person (name, age, job) {
  if(!(this instanceof Person)) {
    return new Person(name, age, job);
  }
  this.name = name ? name : 'no name';
  this.age = age ? age : 0;
  this.job = job ? job : 'no job';
  this.sayHi = sayHi;
}
var sayHi = function () {
    console.log(
        `Hello, I am ${this.name}, I am ${this.age} years old, I am a ${this.job}`
    );
}
var Barney = Person('Barney', 30, 'Business Man');
Barney.sayHi();
```

另一个方法就是配合另一个模式：原型链模式。在JS中，每个函数都有一个prototype的属性，它的所有对象都共享prototype上的属性。所以第二个问题也可以这样解决：

```javascript
function Person (name, age, job) {
  if(!(this instanceof Person)) {
    return new Person(name, age, job);
  }
  this.name = name ? name : 'no name';
  this.age = age ? age : 0;
  this.job = job ? job : 'no job';
  Person.prototype.sayHi = function () {
    console.log(
      `Hello, I am ${this.name}, I am ${this.age} years old, I am a ${this.job}`
    );
  }
}
var Barney = Person('Barney', 30, 'Business Man');
Barney.sayHi();
```

相对而言，原型链模式好的多，因为不用讲属性和方法挂载到全局中，而且this就是指向的构造函数的对象。
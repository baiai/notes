#HTTP缓存原理

http的缓存分为强制缓存和对比缓存，两者的区别在于，强制缓存只要设置的时间不过期，就可以直接拿去用，而不用向服务器再一次发送请求。而对比缓存不管缓存是否有效，都需要向服务器发送请求。

###缓存流程

其过程如下：

　　　　　　　　　　　　　　　　![http文件缓存机制流程图](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141453338-1263276228.png)

1. 浏览器会先查询Cache-Control、Expires来判断内容是否过期，如果没有过期，返回200，直接读取浏览器缓存文件（强制缓存）。在两个属性都存在的情况下，Cache-Control的优先级高于Expires，Cache-Control的值表示的是资源可以先浏览器缓存的时间，Expires的值表示的是资源到期的绝对时间。
2. 在强制缓存没有命中的情况下，浏览器会查找上次文件返回头中是否含有ETag，如果有则将ETag的值赋值给If-None-Match，向服务器发送带有If-None-Match的请求头，服务器判断ETag是否失效，有效返回304读取缓存数据（对比缓存）。失效返回200。ETag是有服务器生成的当前资源的唯一标识，如果资源发生改变，服务器会发送一个新的Etag。
3. 如果没有ETag属性，浏览器端会查找上次文件返回头中是否含有Last-Modified，有则将Last-Modefied的值赋值给If-Modified-Since，向服务器发送带If-Modefied-Since的请求头，服务器判断If-Modefied-Since的值是否有失效，有效返回304读取缓存数据（对比缓存），失效返回200。
4. 如果ETag和Last-Modefied都没有，则直接向服务器发送请求内容。

### ETag和Last-Modefied的区别

从缓存的流程也可以看出，ETag的优先级是高于Last-Modified的。ETag是能解决Last-Modefied比较难解决的问题，比如：

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
3. 某些服务器不能精确的得到文件的最后修改时间。



###强制缓存更新###

对于强制缓存，如果没有过期但是我们资源却已经更新，我们希望能够使用更新的资源的话，由于强制缓存的原因，我们无法获取最新的资源。那么如何解决这个问题呢？

一般情况下，我们会将静态资源和动态网页分集群部署，静态资源放在CDN节点上，可以通过修改动态网页中文件引用路径来获取新资源，但是如果多个文件都更新，那么每次都要重新需要修改多个引用路径就会显得十分麻烦，所以这个时候webpack这样的打包工具就上场了。使用构建工具 webpack ，每次资源修改之后就会变成引用路径，从而使浏览器放弃缓存资源。

具体如何实现参考参考资料。

参考资料：

http://www.cnblogs.com/lyzg/p/5125934.html#_label2

https://juejin.im/entry/598042d15188254ae4503c28

https://www.zhihu.com/question/20790576（张云龙）

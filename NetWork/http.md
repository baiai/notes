### http1.x

#### 持久连接

不需要每次都“三握四挥”的建立连接，可以通过Connection：keep-alive属性保持连接

![img](https://images2015.cnblogs.com/blog/211606/201608/211606-20160807212744637-1476883600.jpg)

#### HTTP管道

每次的请求必须是FIFO的顺序，只有先发送的请求得到响应并传输完成之后，服务器才会处理下一个请求，就是说即使css的优先级高于html文件，但是由于html文件先发送请求，所以必须先相应html文件请求，等html传输完毕再去相应css

![img](https://images2015.cnblogs.com/blog/211606/201608/211606-20160807213633481-1933298397.jpg)

http2.0可以支持多路复用，并按照优先级返回相应

####协议开销

HTTP1.x的增加了请求和相应的首部，造成传输开销增大，而HTTP2.0可以首部压缩，从而减少上面的开销提升性能。

#### 连接与拼合

在HTTP1.x中，我们会采用js合并，css合并，雪碧图等手段减少网络请求来提升性能，在HTTP2.0中支持多向请求和响应，所以可以不同上述操作，减少前端开发的性能优化工作。

#### 嵌入资源

把资源嵌入文档以减少请求次数，比如把js和css代码放在html里面，把图片、音频通过URI嵌入页面中减少请求次数。

### http2.0

http2.0是对http1.x的扩展而非替代。之所以生一个大版本主要是因为它改变了客户端与服务器之间交换数据的方式，http2.0增加了新的`二进制分帧数据层`

#### 二进制分帧数据层

1	位置：封装http消息在客户端和服务器之间传输

2	编码：传输的消息被分割成更小的消息和帧（相对于1.x），并采用二进制格式编码

![img](https://images2015.cnblogs.com/blog/211606/201608/211606-20160807220415840-285627538.jpg)

#### 流、消息、帧

- 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；我的理解是一个流对应着一个完整的HTTP请求和响应
- 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。
- 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等

![img](https://raw.githubusercontent.com/zqjflash/http2-protocol/master/http2-connect-stream.png)

#### 多向请求与响应

在HTTP1.x中要并行请求需要建立多个TCP连接，在HTTP2.0中的二进制分帧层突破了这个限制，客户端和服务器可以将HTTP消息分解为互不依赖的帧然后乱序发送，最后在另一端组合起来。![img](https://images2015.cnblogs.com/blog/211606/201608/211606-20160807221148700-946127515.jpg)

#### 请求优先级

每个stream（流）都带有一个31比特的优先值

#### 一个来源一个连接

服务器和客户端只需要建立一个TCP连接即可

#### 服务器可以主动推送

#### 首部压缩

每次首部发送只会发送有差异的属性。减少请求的体积。

参考资料

https://blog.csdn.net/zqjflash/article/details/50179235



### HTTPS

HTTPS = HTTP + SSL。SSL是安全套接层，因为HTTP协议是明文传输，所以内容都是暴露的，一旦被截去就会产生安全信息泄漏的隐患。为了解决这个问题，在HTTP通信接口部分用SSL和TSL协议代替。SSL是采用`非对称加密`的方式来对信息进行加密的。即加密密钥与解密密钥不是同一个密钥，这可以防止公开密钥被获取后，密文被破译的危险。

但是HTTPS因为加密和解密会消耗更多的CPU资源和内存资源，所以如果不涉及敏感信息，一般还是用HTTP更方便。



### TCP/IP三次握手四次挥手

三次握手见下图：

![1535182847500](C:\Users\baiai\AppData\Local\Temp\1535182847500.png)

在三次握手中，其实前两次就可以建立了连接了，但是为什么要第三次才建立呢？原因是在有传输过程中，有些报文滞后了，但是并没有丢失。如果这个报文在TCP连接关闭之后才发送到Server端，那么Server端会以为Client又在申请TCP连接，然后发送一个确认的报文段，同意建立连接。如果没有三次握手，那么这个时候连接已经建立，但是Client是不会发送报文的，白白浪费了很多资源。所以需要Client端再次确认，即三次握手来避免这种情况。

四次挥手见下图：

![1535183413339](C:\Users\baiai\AppData\Local\Temp\1535183413339.png)

为什么会在2MSL的等待时间才彻底关闭连接呢？原因是我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。
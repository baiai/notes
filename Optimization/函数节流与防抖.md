# 概念

**函数防抖（debounce）**

> 当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间

函数防抖是为了降低一个操作频繁的调用，用一个setTimeout函数将这个操作的调用时间延后，如果在这个期间它又被触发，那么就清除之前的timer，重新创建一个新的timer。

应用场景：实时搜索（keyup）、拖拽（mousemove）、实时输入（input）时都可以用防抖来减少事件触发后函数执行的次数。

**函数节流（throttle）**

> 预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期

函数节流与函数防抖一样是为了减少一个事件触发之后，所需执行的操作的执行次数，与函数防抖不同的是函数节流是在规定的时间内只执行一次。而函数防抖是在规定的时间内没有再次触发则执行，规定时间内再次触发，则时间再次延后delay时间。

应用场景：窗口调整（resize）、页面滚动（scroll）、疯狂抢购点击（mousedown）



# demo

**函数防抖**

函数防抖以一个input事件为例。在用户输入的时候，可能用户当前输入并不是最终输入，但是有需要做到实时，那么就可以用函数防抖，在用户输入停止500ms后，就会响应一个它的输入。

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Debounce</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <input type="text">
</body>
<script>
    let timer = null
    document.querySelector('input').addEventListener('input', function(e) {
        clearTimeout(timer) // 如果500ms内再次触发input则清除timer
        timer = setTimeout(() => {
            console.log(e.target.value)
        }, 500)
    })
</script>
</html>
```

**函数节流**

函数节流以一个点击事件为例，一秒以内只能执行一次点击触发之后的操作。在抢购过程中，全国各地的用户都在疯狂点击，会浪费很多资源去响应这些操作，如果将点击触发效果减少到1s一次，可以很大程度上缓和压力。

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <script src="./app.js"></script> -->
</head>
<body>
    <button>抢购</button>
</body>
<script>
    let timer = null, isClick = false
    document.querySelector('button').addEventListener('click', function() {
        if(!isClick) {
            timer = setTimeout(() => {
                console.log('clicked')
                isClick = false // 1s后将isClick设为false就又可以触发点击了
            }, 1000)
            isClick = true
        }
    })
</script>
</html>
```


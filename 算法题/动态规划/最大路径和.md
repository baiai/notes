矩阵的最小路径和
【题目】
给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。
【举例】
如果给定的m如下：
1　3　5　9
8　1　3　4
5　0　6　1
8　8　4　0
路径1，3，1，0，6，1，0是所有路径中路径和最小的，所以返回12。

```ts
function minPath(arr: number[][]): number {
    let dp: number[][] = []
    let row: number = arr.length
    let col: number = arr[0].length
    // init dp[][]
    for(let i = 0; i < row; i++){
        dp[i] = []
    }
    dp[0][0] = arr[0][0]
    for (let i = 1; i < col; i++) {
        dp[0][i] = dp[0][i - 1] + arr[0][i]
    }
    for (let j = 1; j < row; j++) {
        dp[j][0] = dp[j - 1][0] + arr[j][0]
    }
    for (let i = 1; i < row; i++) {
        for (let j = 1; j < col; j++) {
            dp[i][j] = (dp[i - 1][j] < dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1]) + arr[i][j]
        }
    }
    console.log(dp)
    return dp[row - 1][col - 1]
}

let arr1: number[][] = [
    [1, 3, 5, 9],
    [8, 1, 3, 4],
    [5, 0, 6, 1],
    [8, 8, 4, 0]
]
console.log( minPath(arr1))
```

以上是最初版本的，空复杂度是（M+N)，我们还可以在压缩一下，变成max{M, N}

```ts
function minPath2(arr: number[][]): number {
    let dp: number[] = []
    let row: number = arr.length
    let col: number = arr[0].length
    dp[0] = arr[0][0]
    for (let i = 1; i < col; i++) {
        dp[i] = dp[i - 1] + arr[0][i]
    }
    for (let i = 1; i < row; i++) {
        dp[0] = dp[0] + arr[i][0]
        for (let j = 1; j < col; j++) {
            dp[j] = (dp[j - 1] < dp[j] ? dp[j - 1] : dp[j]) + arr[i][j]
        }
    }
    console.log(dp)
    return dp[col - 1]
}
let arr1: number[][] = [
    [1, 3, 5, 9],
    [8, 1, 3, 4],
    [5, 0, 6, 1],
    [8, 8, 4, 0]
]
console.log( minPath2(arr1))
```


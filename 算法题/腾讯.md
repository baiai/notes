# 小Q的歌单

解法1：拿出i个A长度的歌，看剩下长度的能否被B整除，能的话求出余数divisor，然后X中拿出i个的取法有m中，Y中拿出divisor的取法有n种。合起来就是m*n，遍历i得到一共拿了多少种。

```js
const readline = require('readline')

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

let inputs = [], count = 0
rl.on('line', (input) => {
  count++
  if (count === 1)
    inputs.push(input)
  else {
    let ans = input.trim().split(' ')
    ans.forEach(item => {
      inputs.push(Number(item))
    })
    let sum = solution(...inputs)
    console.log(sum)
    rl.close()
  }
})


function solution (lenSum, len1, count1, len2, count2) {
  let sum = 0
  for (let i = 0; i <= count1; i++) {
    if (i * len1 < lenSum &&
      (lenSum - (i * len1))%count2 === 0 &&
      (lenSum - (i * len1))/count2 <= len2) {
      let divisor = (lenSum - (i * len1))/count2
      sum += howMany(i, count1) * howMany(divisor, count2)
    }
  }
  return sum
}
// 从c2中取出c1个数的取法
function howMany (c1, c2) {
  if (c1 === 0)
    return 0
  let numerator = 1, denominator = 1
  for (let i = 0; i < c1; i++) {
    numerator *= ( c2 - i )
    denominator *= ( c1 - i )
  }
  return numerator/denominator
}

```



# 安排机器

```js
题目描述：小Q的公司最近接到m个任务，第i个任务需要Xi的时间去完成，难度等级为yi。
                小Q拥有n台机器，每台机器最长工作时间zi，机器等级wi。
               对于一个任务，它只能交由一台机器来完成，如果安排给它的机器的最长工作时间小于任务需要的时间，则不能完成，
                如果完成这个任务将获得200*xi + 3*yi收益。
                对于一台机器，它一天只能完成一个任务，如果它的机器等级小于安排给它的任务难度等级，则不能完成。
               小Q想在今天尽可能的去完成任务，即完成的任务数量最大。如果有多种安排方案，小Q还想找到收益最大的那个方案。小Q需要你来帮助他计算一下。
           输入描述：输入包括 N + M + 1行
                 输入的第一行为两个正整数n和m（1 <= n, m <= 100000），表示机器的数量和任务的数量。
                 接下来n行，每行两个整数zi和wi（0 < zi < 1000, 0 <= wi <= 100），表示每台机器的最大工作时间和机器等级。
                 接下来的m行，每行两个整数xi和yi（0 < xi < 1000, 0 <= yi <= 100），表示每个任务需要的完成时间和任务的难度等级。
           输出描述：输出两个整数，分别表示最大能完成的任务数量和获取的利益。
           输入： 1 2
               100 3
               100 2
               100 1
           输出：1 20006
```

思路：将每个机器和任务按照时间优先降序排序，然后每台机器在找到最合适的任务，算出匹配任务总数和对应的时间。

```js
/*
机器数n
任务数m
每台机器的最大工作时间zi
每台机器的等级wi
每个任务的完成时间xi
每个任务的完成难度yi
*/
// 将每台机器按工作时间和等级降序排序
// 将每个人物按时间和难度降序排序

const readline = require('readline')
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})
let inputLine = 0
let n,m
let machine = [], task = []
rl.on('line', (input) => {
  inputLine++
  if (inputLine === 1) {
    let arrTmp = input.trim().split(' ')
    n = Number(arrTmp[0])
    m = Number(arrTmp[1])
  } else if (inputLine <= n+1) {
    let arrTmp = input.trim().split(' ')
    machine.push({
      time: Number(arrTmp[0]),
      level: Number(arrTmp[1]),
      flag: false
    })
  } else if (inputLine <= n + m + 1) {
    let arrTmp = input.trim().split(' ')
    task.push({
      time: Number(arrTmp[0]),
      level: Number(arrTmp[1]),
      flag: false
    })
  } 
  if (inputLine === n + m + 1) {
    machine.sort(cmp)
    task.sort(cmp)
    solution(n, m, machine, task)
    rl.close()
  }
})

function cmp (item1, item2) {
  if (item1.time === item2.time)
    return item2.level - item1.level
  return item2.time - item1.time
}

function solution (n, m, machine, task) {
  let count = 0, profit = 0
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (task[j].time <= machine[i].time &&
        task[j].level <= machine[i].level &&
        task[j].flag === false) {
        count++
        profit += (200 * task[j].time + 3 * task[j].level)
        task[j].flag = true
        break
      }
    }
  }
  console.log(count, profit)
  return {
    count,
    profit
  }
}
```



# 画家小Q

```js
const readline = require('readline')
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

let count = 0
let row, col, arrTmp = []
let paintBoard = []
rl.on('line', (input) => {
  count++
  if (count === 1) {
    arrTmp = input.trim().split(' ')
    row = Number(arrTmp[0])
    col = Number(arrTmp[1])
  } else if (count <= row + 1) {
    arrTmp = input.trim().split('')
    paintBoard.push(arrTmp)
  } 
  if (count === row + 1) {
    console.log(solution(row, col, paintBoard))
    rl.close()
  }
})

function solution (row, col, arr) {
  let counter = 0
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      if (arr[i][j] === 'B') {
        let r = i, c = j
        while (r < row && c >= 0) {
          if (arr[r][c] === 'B') {
            arr[r][c] = 'X'
          } else if (arr[r][c] === 'G') {
            arr[r][c] = 'Y'
          }
          r++
          c--
        }
        counter++
      } else if (arr[i][j] === 'Y') {
        let r = i, c = j
        while (r < row && c < col) {
          if (arr[r][c] === 'Y') {
            arr[r][c] = 'X'
          } else if (arr[r][c] === 'G') {
            arr[r][c] = 'B'
          }
          r++
          c++
        }
        counter++
      } else if (arr[i][j] === 'G') {
        let r1 = i, c1 = j, r2 = i, c2 = j
        while (r1 < row && c1 >= 0) {
          if (arr[r1][c1] === 'B') {
            arr[r1][c1] = 'X'
          } else if (arr[r1][c1] === 'G') {
            arr[r1][c1] = 'Y'
          }
          r1++
          c1--
        }
        while (r2 < row && c2 < col) {
          if (arr[r2][c2] === 'B') {
            arr[r2][c2] = 'X'
          } else if (arr[r2][c2] === 'G') {
            arr[r2][c2] = 'Y'
          }
          r1++
          c1--
        }
        counter += 2
      }
    }
  }
  return counter
}
```



# 贪吃的小Q

```js
/* const readline = require('readline')

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
})
let arrTmp = [],
    day, num
rl.on('line', (input) => {
    arrTmp = input.trim().split(' ')
    day = Number(arrTmp[0])
    num = Number(arrTmp[1])
    console.log(solution(day, num))
    rl.close()
}) */

solution(3, 7)

function solution(day, num) {
    let low = 1,
        high = day,
        mid, result
    while (low <= high) {
        mid = Math.ceil((low + high + 1) / 2)
        result = sum(day, mid)
        if (result === num) {
            return mid
        } else if (result < num) {
            low = mid
        } else {
            high = mid - 1
        }
    }
    return high
}

function sum(day, num) {
    let sum = 0
    for (let i = 0; i < day; i++) {
        if (num <= 0)
            return false
        sum += num
        num = Math.ceil(num / 2)
    }
    return sum
}
```



# 纸牌算法

```js
const readline = require('readline')

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
})
let arrTmp = [], nline = 1, num, arr = []
rl.on('line', (input) => {
    if (nline === 1) {
        num = Number(input)
        nline++
    } else {
        arrTmp = input.trim().split(' ')
        for (let i = 0; i< arrTmp.length; i++) {
            arr.push(Number(arrTmp[i]))
        }
        console.log(solution(arr))
        rl.close()
    }  
})

// 最大堆
let maxHeap = {
    _arr: [null], // 默认是从1这个index开始存储的
    init: function (arr) {
        if (arr) {
            for (let i = 0; i < arr.length; i++) {
                maxHeap.push(arr[i])
            }
            console.log(maxHeap._arr)
        }
    },
    pop: function () {
        let del = maxHeap._arr[1]
        maxHeap._arr[1] = maxHeap._arr[maxHeap._arr.length - 1]
        maxHeap._arr.length--
        let k = 1
        while (k * 2 <= maxHeap._arr.length - 1) {
            let j = k * 2
            if (j + 1 <= maxHeap._arr.length - 1 && maxHeap._arr[j + 1] > maxHeap._arr[j]) {
                j++
            }
            if (maxHeap._arr[k] >= maxHeap._arr[j]) {
                break
            }
            let tmp = maxHeap._arr[k]
            maxHeap._arr[k] = maxHeap._arr[j]
            maxHeap._arr[j] = tmp
            k = j
        }
        return del
    },
    push: function (item) {
        let k = maxHeap._arr.length
        maxHeap._arr.push(item)      
        while (k > 1 && maxHeap._arr[Math.floor(k/2)] < maxHeap._arr[k]) {
            let tmp = maxHeap._arr[k]
            maxHeap._arr[k] = maxHeap._arr[Math.floor(k/2)]
            maxHeap._arr[Math.floor(k/2)] = tmp
            k = Math.floor(k/2)
        }
        return maxHeap._arr
    }
}

function solution (arr) {
    let arrA = [], arrB = []
    maxHeap.init(arr)
    for (let i = 0; i < arr.length; i++) {
        if (i%2 === 0) {
            arrA.push(maxHeap.pop())
        } else {
            arrB.push(maxHeap.pop())
        }
    }
    console.log(arrA, arrB)
    let sumA = 0, sumB = 0
    arrA.forEach(item => {
        sumA += item
    })
    arrB.forEach(item => {
        sumB += item
    })
    return sumA - sumB
}

solution(arr)
```


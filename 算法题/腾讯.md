# 小Q的歌单

解法1：拿出i个A长度的歌，看剩下长度的能否被B整除，能的话求出余数divisor，然后X中拿出i个的取法有m中，Y中拿出divisor的取法有n种。合起来就是m*n，遍历i得到一共拿了多少种。

```js
const readline = require('readline')

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

let inputs = [], count = 0
rl.on('line', (input) => {
  count++
  if (count === 1)
    inputs.push(input)
  else {
    let ans = input.trim().split(' ')
    ans.forEach(item => {
      inputs.push(Number(item))
    })
    let sum = solution(...inputs)
    console.log(sum)
    rl.close()
  }
})


function solution (lenSum, len1, count1, len2, count2) {
  let sum = 0
  for (let i = 0; i <= count1; i++) {
    if (i * len1 < lenSum &&
      (lenSum - (i * len1))%count2 === 0 &&
      (lenSum - (i * len1))/count2 <= len2) {
      let divisor = (lenSum - (i * len1))/count2
      sum += howMany(i, count1) * howMany(divisor, count2)
    }
  }
  return sum
}
// 从c2中取出c1个数的取法
function howMany (c1, c2) {
  if (c1 === 0)
    return 0
  let numerator = 1, denominator = 1
  for (let i = 0; i < c1; i++) {
    numerator *= ( c2 - i )
    denominator *= ( c1 - i )
  }
  return numerator/denominator
}

```



# 安排机器

```js
题目描述：小Q的公司最近接到m个任务，第i个任务需要Xi的时间去完成，难度等级为yi。
                小Q拥有n台机器，每台机器最长工作时间zi，机器等级wi。
               对于一个任务，它只能交由一台机器来完成，如果安排给它的机器的最长工作时间小于任务需要的时间，则不能完成，
                如果完成这个任务将获得200*xi + 3*yi收益。
                对于一台机器，它一天只能完成一个任务，如果它的机器等级小于安排给它的任务难度等级，则不能完成。
               小Q想在今天尽可能的去完成任务，即完成的任务数量最大。如果有多种安排方案，小Q还想找到收益最大的那个方案。小Q需要你来帮助他计算一下。
           输入描述：输入包括 N + M + 1行
                 输入的第一行为两个正整数n和m（1 <= n, m <= 100000），表示机器的数量和任务的数量。
                 接下来n行，每行两个整数zi和wi（0 < zi < 1000, 0 <= wi <= 100），表示每台机器的最大工作时间和机器等级。
                 接下来的m行，每行两个整数xi和yi（0 < xi < 1000, 0 <= yi <= 100），表示每个任务需要的完成时间和任务的难度等级。
           输出描述：输出两个整数，分别表示最大能完成的任务数量和获取的利益。
           输入： 1 2
               100 3
               100 2
               100 1
           输出：1 20006
```

思路：将每个机器和任务按照时间优先降序排序，然后每台机器在找到最合适的任务，算出匹配任务总数和对应的时间。

```js
/*
机器数n
任务数m
每台机器的最大工作时间zi
每台机器的等级wi
每个任务的完成时间xi
每个任务的完成难度yi
*/
// 将每台机器按工作时间和等级降序排序
// 将每个人物按时间和难度降序排序

const readline = require('readline')
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})
let inputLine = 0
let n,m
let machine = [], task = []
rl.on('line', (input) => {
  inputLine++
  if (inputLine === 1) {
    let arrTmp = input.trim().split(' ')
    n = Number(arrTmp[0])
    m = Number(arrTmp[1])
  } else if (inputLine <= n+1) {
    let arrTmp = input.trim().split(' ')
    machine.push({
      time: Number(arrTmp[0]),
      level: Number(arrTmp[1]),
      flag: false
    })
  } else if (inputLine <= n + m + 1) {
    let arrTmp = input.trim().split(' ')
    task.push({
      time: Number(arrTmp[0]),
      level: Number(arrTmp[1]),
      flag: false
    })
  } 
  if (inputLine === n + m + 1) {
    machine.sort(cmp)
    task.sort(cmp)
    solution(n, m, machine, task)
    rl.close()
  }
})

function cmp (item1, item2) {
  if (item1.time === item2.time)
    return item2.level - item1.level
  return item2.time - item1.time
}

function solution (n, m, machine, task) {
  let count = 0, profit = 0
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (task[j].time <= machine[i].time &&
        task[j].level <= machine[i].level &&
        task[j].flag === false) {
        count++
        profit += (200 * task[j].time + 3 * task[j].level)
        task[j].flag = true
        break
      }
    }
  }
  console.log(count, profit)
  return {
    count,
    profit
  }
}
```

